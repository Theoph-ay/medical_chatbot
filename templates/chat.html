<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description"
        content="Medical AI Chatbot ‚Äî get evidence-based answers from Hutchinson's Clinical Methods." />
    <title>MedAssist AI ‚Äî Medical Chatbot</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}" />
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ü©∫</text></svg>" />
</head>

<body>

    <div class="chat-wrapper">
        <!-- ===== Header ===== -->
        <header class="chat-header">
            <div class="header-icon">ü©∫</div>
            <div class="header-info">
                <h1>MedAssist AI</h1>
                <p>Evidence-based medical assistant</p>
            </div>
            <div class="header-status">
                <span class="status-dot"></span>
                Online
            </div>
        </header>

        <!-- ===== Messages ===== -->
        <main class="chat-messages" id="chat-messages">

            <!-- Welcome card -->
            <div class="welcome-card" id="welcome-card">
                <div class="welcome-icon">üè•</div>
                <h2>Welcome to MedAssist AI</h2>
                <p>Ask any medical question ‚Äî I'll retrieve evidence-based answers from medical textbooks, pediatric
                    slides, and surgical literature.</p>

                <div class="quick-prompts">
                    <button class="quick-prompt"
                        data-prompt="What are the signs and symptoms of appendicitis?">Appendicitis signs</button>
                    <button class="quick-prompt" data-prompt="Explain the pathophysiology of heart failure">Heart
                        failure</button>
                    <button class="quick-prompt" data-prompt="What is the management of neonatal jaundice?">Neonatal
                        jaundice</button>
                    <button class="quick-prompt" data-prompt="Describe the surgical approach for craniotomy">Craniotomy
                        approach</button>
                </div>
            </div>

            <!-- Typing indicator -->
            <div class="typing-indicator" id="typing-indicator">
                <div class="avatar">ü§ñ</div>
                <div class="typing-dots">
                    <span></span><span></span><span></span>
                </div>
            </div>
        </main>

        <!-- ===== Input Area ===== -->
        <footer class="chat-input-area">
            <form class="input-wrapper" id="chat-form" autocomplete="off">
                <textarea id="user-input" placeholder="Ask a medical question..." rows="1" autofocus></textarea>
                <button type="submit" id="send-btn" aria-label="Send message">
                    <svg viewBox="0 0 24 24">
                        <line x1="22" y1="2" x2="11" y2="13"></line>
                        <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                    </svg>
                </button>
            </form>

            <!-- Tech stack branding -->
            <div class="footer-branding">
                <span class="disclaimer-text">For educational purposes only ‚Äî always consult a healthcare
                    professional.</span>
                <div class="tech-badges">
                    <span class="tech-badge"><span class="badge-icon">üêç</span> Python</span>
                    <span class="tech-badge"><span class="badge-icon">üå∂Ô∏è</span> Flask</span>
                    <span class="tech-badge"><span class="badge-icon">ü¶ú</span> LangChain</span>
                    <span class="tech-badge"><span class="badge-icon">üå≤</span> Pinecone</span>
                </div>
            </div>
        </footer>
    </div>

    <!-- ============================== -->
    <!--        JavaScript Logic        -->
    <!-- ============================== -->
    <script>
        (function () {
            'use strict';

            const chatMessages = document.getElementById('chat-messages');
            const chatForm = document.getElementById('chat-form');
            const userInput = document.getElementById('user-input');
            const sendBtn = document.getElementById('send-btn');
            const typingIndicator = document.getElementById('typing-indicator');
            const welcomeCard = document.getElementById('welcome-card');

            // ---- Auto-resize textarea ----
            userInput.addEventListener('input', () => {
                userInput.style.height = 'auto';
                userInput.style.height = Math.min(userInput.scrollHeight, 120) + 'px';
            });

            // ---- Submit on Enter (Shift+Enter for newline) ----
            userInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    chatForm.dispatchEvent(new Event('submit'));
                }
            });

            // ---- Quick prompt buttons ----
            document.querySelectorAll('.quick-prompt').forEach((btn) => {
                btn.addEventListener('click', () => {
                    userInput.value = btn.dataset.prompt;
                    userInput.dispatchEvent(new Event('input'));
                    chatForm.dispatchEvent(new Event('submit'));
                });
            });

            // ---- Form submit handler ----
            chatForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const query = userInput.value.trim();
                if (!query) return;

                if (welcomeCard) welcomeCard.remove();

                appendMessage('user', query);

                userInput.value = '';
                userInput.style.height = 'auto';
                userInput.focus();

                showTyping(true);
                setInputState(false);

                try {
                    const formData = new FormData();
                    formData.append('query', query);

                    const res = await fetch('/chat', {
                        method: 'POST',
                        body: formData,
                    });

                    if (!res.ok) throw new Error(`Server error: ${res.status}`);

                    const data = await res.json();
                    const answer = data.response || 'Sorry, I could not generate a response.';

                    showTyping(false);
                    appendMessage('ai', answer);
                } catch (err) {
                    console.error('Fetch error:', err);
                    showTyping(false);
                    appendMessage('ai', '‚ö†Ô∏è Something went wrong while connecting to the server. Please try again.');
                } finally {
                    setInputState(true);
                }
            });

            // ---- Helpers ----

            function appendMessage(role, text) {
                const msgDiv = document.createElement('div');
                msgDiv.classList.add('message', role);

                if (role === 'ai') {
                    const avatar = document.createElement('div');
                    avatar.className = 'avatar';
                    avatar.textContent = 'ü§ñ';
                    msgDiv.appendChild(avatar);
                }

                const bubble = document.createElement('div');
                bubble.className = 'bubble';

                if (role === 'ai') {
                    bubble.innerHTML = renderMarkdown(text);
                } else {
                    bubble.textContent = text;
                }

                msgDiv.appendChild(bubble);
                chatMessages.insertBefore(msgDiv, typingIndicator);
                scrollToBottom();
            }

            function showTyping(show) {
                typingIndicator.classList.toggle('visible', show);
                if (show) scrollToBottom();
            }

            function setInputState(enabled) {
                userInput.disabled = !enabled;
                sendBtn.disabled = !enabled;
            }

            function scrollToBottom() {
                requestAnimationFrame(() => {
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                });
            }

            /**
             * Markdown renderer with TABLE support.
             * Handles: tables, fenced code, bold, italic, inline code,
             * unordered/ordered lists, headings, line breaks.
             */
            function renderMarkdown(text) {
                text = text.replace(/\r\n/g, '\n');

                // Fenced code blocks ```...```
                text = text.replace(/```([\s\S]*?)```/g, (_, code) => {
                    return '\x00PRE' + btoa(unescape(encodeURIComponent(code.trim()))) + 'PRE\x00';
                });

                // Inline code
                text = text.replace(/`([^`]+)`/g, '<code>$1</code>');

                // Bold
                text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');

                // Italic
                text = text.replace(/(?<!\*)\*(?!\*)(.+?)(?<!\*)\*(?!\*)/g, '<em>$1</em>');

                const lines = text.split('\n');
                let html = '';
                let inUl = false;
                let inOl = false;
                let i = 0;

                while (i < lines.length) {
                    const line = lines[i];

                    // --- Detect markdown tables ---
                    // A table starts with a line containing |, followed by a separator line |---|
                    if (line.includes('|') && i + 1 < lines.length && /^\s*\|?\s*[-:]+[-|:\s]+\s*\|?\s*$/.test(lines[i + 1])) {
                        // Close any open list
                        if (inUl) { html += '</ul>'; inUl = false; }
                        if (inOl) { html += '</ol>'; inOl = false; }

                        html += parseTable(lines, i);

                        // Skip past the table rows
                        i++; // header
                        i++; // separator
                        while (i < lines.length && lines[i].includes('|') && lines[i].trim() !== '') {
                            i++;
                        }
                        continue;
                    }

                    // --- Restore fenced code blocks ---
                    const preMatch = line.match(/\x00PRE(.+?)PRE\x00/);
                    if (preMatch) {
                        if (inUl) { html += '</ul>'; inUl = false; }
                        if (inOl) { html += '</ol>'; inOl = false; }
                        const decoded = decodeURIComponent(escape(atob(preMatch[1])));
                        html += '<pre><code>' + escapeHtml(decoded) + '</code></pre>';
                        i++;
                        continue;
                    }

                    // Unordered list
                    const ulMatch = line.match(/^\s*[-*]\s+(.+)/);
                    const olMatch = line.match(/^\s*\d+\.\s+(.+)/);

                    if (ulMatch) {
                        if (inOl) { html += '</ol>'; inOl = false; }
                        if (!inUl) { html += '<ul>'; inUl = true; }
                        html += '<li>' + ulMatch[1] + '</li>';
                        i++;
                        continue;
                    } else if (inUl && !ulMatch) {
                        html += '</ul>';
                        inUl = false;
                    }

                    if (olMatch) {
                        if (inUl) { html += '</ul>'; inUl = false; }
                        if (!inOl) { html += '<ol>'; inOl = true; }
                        html += '<li>' + olMatch[1] + '</li>';
                        i++;
                        continue;
                    } else if (inOl && !olMatch) {
                        html += '</ol>';
                        inOl = false;
                    }

                    // Headings
                    const headingMatch = line.match(/^(#{1,4})\s+(.+)/);
                    if (headingMatch) {
                        html += `<strong>${headingMatch[2]}</strong><br/>`;
                        i++;
                        continue;
                    }

                    // Empty line
                    if (line.trim() === '') {
                        html += '<br/>';
                    } else {
                        html += '<p>' + line + '</p>';
                    }
                    i++;
                }

                if (inUl) html += '</ul>';
                if (inOl) html += '</ol>';

                return html;
            }

            /**
             * Parse a markdown table starting at lines[startIndex].
             * Returns HTML string for the table.
             */
            function parseTable(lines, startIndex) {
                let idx = startIndex;

                // Parse header row
                const headerCells = parseTableRow(lines[idx]);
                idx++; // move past header

                // Skip separator row (|---|---|)
                idx++;

                // Parse body rows
                const bodyRows = [];
                while (idx < lines.length && lines[idx].includes('|') && lines[idx].trim() !== '') {
                    bodyRows.push(parseTableRow(lines[idx]));
                    idx++;
                }

                // Build HTML
                let tableHtml = '<div class="table-wrapper"><table>';

                // thead
                tableHtml += '<thead><tr>';
                for (const cell of headerCells) {
                    tableHtml += '<th>' + cell + '</th>';
                }
                tableHtml += '</tr></thead>';

                // tbody
                tableHtml += '<tbody>';
                for (const row of bodyRows) {
                    tableHtml += '<tr>';
                    for (let c = 0; c < row.length; c++) {
                        tableHtml += '<td>' + row[c] + '</td>';
                    }
                    tableHtml += '</tr>';
                }
                tableHtml += '</tbody></table></div>';

                return tableHtml;
            }

            /** Split a markdown table row like "| a | b | c |" into ['a','b','c'] */
            function parseTableRow(line) {
                let trimmed = line.trim();
                if (trimmed.startsWith('|')) trimmed = trimmed.substring(1);
                if (trimmed.endsWith('|')) trimmed = trimmed.substring(0, trimmed.length - 1);
                return trimmed.split('|').map(cell => cell.trim());
            }

            function escapeHtml(str) {
                const div = document.createElement('div');
                div.textContent = str;
                return div.innerHTML;
            }

        })();
    </script>

</body>

</html>